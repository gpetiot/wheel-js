<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wheel Spinner</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="app">
        <div class="container">
            <h1>Wheel Spinner</h1>
            <div class="app-layout">
                <!-- Wheel Section -->
                <div class="wheel-section">
                    <div class="wheel-container">
                        <div class="wheel-indicator"></div>
                        <div class="wheel" id="wheel">
                            <!-- Wheel slices will be generated by JavaScript -->
                        </div>
                    </div>
                    
                    <button 
                        class="spin-button" 
                        id="spin-button">
                        Spin the Wheel
                    </button>
                    
                    <div class="result-message" id="result-message" style="display: none;">
                        Result: <strong id="result"></strong>
                    </div>
                </div>
                
                <!-- Choices Table Section -->
                <div class="table-section">
                    <h2>Your Choices</h2>
                    
                    <div class="choices-container">
                        <ul id="choices-list" class="choices-list">
                            <!-- Choices will be generated by JavaScript -->
                        </ul>
                        
                        <!-- Add new choice input as the last row -->
                        <div class="new-choice-row">
                            <div class="new-choice-input-container">
                                <span class="plus-icon">+</span>
                                <input
                                    type="text"
                                    id="new-choice"
                                    placeholder="Add a new choice and press Enter"
                                    class="new-choice-input"
                                />
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Colors for the wheel slices
        const COLORS = [
            '#16a34a', '#0ea5e9', '#6366f1', '#8b5cf6', 
            '#ec4899', '#f43f5e', '#fb923c', '#fbbf24',
            '#84cc16', '#10b981', '#06b6d4', '#3b82f6'
        ];

        // Application state
        const state = {
            choices: [],
            rotation: 0,
            isSpinning: false,
            result: ''
        };

        // DOM References
        const wheel = document.getElementById('wheel');
        const spinButton = document.getElementById('spin-button');
        const resultMessage = document.getElementById('result-message');
        const resultElement = document.getElementById('result');
        const newChoiceInput = document.getElementById('new-choice');
        const choicesList = document.getElementById('choices-list');

        // Render the wheel slices
        function renderWheel() {
            // Clear existing wheel slices
            wheel.innerHTML = '';
            
            // Get wheel choices
            const wheelSlices = getWheelSlices();
            
            // If there are no choices, show an empty wheel with message
            if (wheelSlices.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-wheel-message';
                emptyMessage.innerHTML = 'Add choices<br>to start';
                wheel.appendChild(emptyMessage);
                return;
            }
            
            // Create SVG for wheel
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svg.setAttribute("viewBox", "0 0 100 100");
            
            // Calculate center point
            const centerX = 50;
            const centerY = 50;
            const radius = 50;
            
            // Create sectors using SVG paths
            wheelSlices.forEach((slice, index) => {
                // Calculate start and end angles
                const startAngle = slice.rotate * (Math.PI / 180);
                const endAngle = (slice.rotate + slice.sliceAngle) * (Math.PI / 180);
                
                // Calculate points on the circle
                const startX = centerX + radius * Math.cos(startAngle);
                const startY = centerY + radius * Math.sin(startAngle);
                const endX = centerX + radius * Math.cos(endAngle);
                const endY = centerY + radius * Math.sin(endAngle);
                
                // Create SVG path for sector
                const largeArcFlag = slice.sliceAngle > 180 ? 1 : 0;
                const pathData = [
                    `M ${centerX},${centerY}`,  // Move to center
                    `L ${startX},${startY}`,    // Line to start point on circle
                    `A ${radius},${radius} 0 ${largeArcFlag} 1 ${endX},${endY}`, // Arc to end point
                    'Z'                         // Close path
                ].join(' ');
                
                // Create sector path element
                const sector = document.createElementNS(svgNS, "path");
                sector.setAttribute("d", pathData);
                sector.setAttribute("fill", slice.color || '#6366f1');
                sector.setAttribute("stroke", "white");
                sector.setAttribute("stroke-width", "1");
                sector.setAttribute("data-slice-index", index);
                
                svg.appendChild(sector);
                
                // Create text in the sector
                const textAngle = startAngle + (slice.sliceAngle / 2) * (Math.PI / 180);
                const textRadius = radius * 0.75; // Place text at 75% of the radius
                const textX = centerX + textRadius * Math.cos(textAngle);
                const textY = centerY + textRadius * Math.sin(textAngle);
                
                const text = document.createElementNS(svgNS, "text");
                text.setAttribute("x", textX);
                text.setAttribute("y", textY);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("dominant-baseline", "middle");
                text.setAttribute("fill", "white");
                text.setAttribute("font-size", slice.sliceAngle > 45 ? "3" : "2.5");
                text.setAttribute("font-weight", "bold");
                
                // Calculate text rotation to make it readable
                // Convert from radians to degrees and adjust to keep text horizontal
                const textRotationDegrees = (textAngle * 180 / Math.PI) + 90;
                // Adjust text rotation to ensure it's always readable (not upside down)
                const adjustedRotation = textRotationDegrees > 180 && textRotationDegrees < 360 
                    ? textRotationDegrees + 180 
                    : textRotationDegrees;
                
                text.setAttribute("transform", `rotate(${adjustedRotation}, ${textX}, ${textY})`);
                text.setAttribute("text-shadow", "0 0 1px black");
                
                // Add a title for better accessibility
                const title = document.createElementNS(svgNS, "title");
                title.textContent = slice.text;
                text.appendChild(title);
                
                // Break text into multiple lines if needed
                const words = slice.text.split(' ');
                if (words.length > 1 && slice.sliceAngle < 45) {
                    // For smaller slices with multiple words, break into lines
                    const tspan1 = document.createElementNS(svgNS, "tspan");
                    tspan1.setAttribute("x", textX);
                    tspan1.setAttribute("dy", "-0.6em");
                    tspan1.textContent = words.slice(0, Math.ceil(words.length/2)).join(' ');
                    
                    const tspan2 = document.createElementNS(svgNS, "tspan");
                    tspan2.setAttribute("x", textX);
                    tspan2.setAttribute("dy", "1.2em");
                    tspan2.textContent = words.slice(Math.ceil(words.length/2)).join(' ');
                    
                    text.appendChild(tspan1);
                    text.appendChild(tspan2);
                } else {
                    text.textContent = slice.text;
                }
                
                svg.appendChild(text);
            });
            
            wheel.appendChild(svg);
        }

        // Render the choices list
        function renderChoicesList() {
            // Clear existing choices
            choicesList.innerHTML = '';
            
            if (state.choices.length === 0) {
                const emptyItem = document.createElement('li');
                emptyItem.className = 'empty-message';
                emptyItem.textContent = 'No choices added yet';
                choicesList.appendChild(emptyItem);
                return;
            }
            
            // Create list items for each choice
            state.choices.forEach((choice, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'choice-item';
                listItem.setAttribute('data-index', index);
                
                if (choice.editing) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'edit-input';
                    input.value = choice.editValue;
                    input.onkeyup = (e) => {
                        choice.editValue = e.target.value;
                        if (e.key === 'Enter') {
                            updateChoice(index);
                        }
                    };
                    input.onblur = () => updateChoice(index);
                    
                    listItem.appendChild(input);
                    
                    // Focus the input after rendering
                    setTimeout(() => input.focus(), 10);
                } else {
                    // Choice content
                    const choiceContent = document.createElement('div');
                    choiceContent.className = 'choice-content';
                    
                    // Text element
                    const textElement = document.createElement('span');
                    textElement.className = 'choice-text';
                    textElement.textContent = choice.text;
                    textElement.onclick = () => startEdit(index);
                    
                    // Edit hint
                    const editHint = document.createElement('span');
                    editHint.className = 'edit-hint';
                    editHint.textContent = 'Click to edit';
                    
                    choiceContent.appendChild(textElement);
                    choiceContent.appendChild(editHint);
                    
                    // Delete button
                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'delete-button';
                    deleteButton.innerHTML = '&times;';
                    deleteButton.onclick = (e) => {
                        e.stopPropagation();
                        deleteChoice(index);
                    };
                    
                    listItem.appendChild(choiceContent);
                    listItem.appendChild(deleteButton);
                }
                
                choicesList.appendChild(listItem);
            });
        }

        // Calculate wheel slices data
        function getWheelSlices() {
            // Get choices texts
            const choiceTexts = state.choices.map(choice => choice.text);
            
            // If there are no choices, return an empty array
            if (choiceTexts.length === 0) {
                return [];
            }
            
            let slices = [];
            
            // If fewer than 6 choices, duplicate each choice to appear on opposite sides
            if (choiceTexts.length < 6) {
                // Each distinct choice gets a specific angle
                const choiceAngle = 360 / choiceTexts.length;
                // Each slice is half the size of the total angle for a choice
                const sliceAngle = choiceAngle / 2;
                
                // Create slices with each choice appearing twice with the SAME color
                choiceTexts.forEach((text, i) => {
                    // Determine color for this choice - each distinct choice gets a different color
                    // Ensure we have a valid color by defaulting to a fallback if needed
                    const colorIndex = i % COLORS.length;
                    const choiceColor = COLORS[colorIndex] || '#6366f1'; // Default to indigo if color is missing
                    
                    // Calculate base rotation for this choice
                    const baseRotation = i * choiceAngle;
                    
                    // First occurrence
                    slices.push({
                        text: text,
                        color: choiceColor,
                        rotate: baseRotation,  // At the base rotation
                        sliceAngle: sliceAngle
                    });
                    
                    // Second occurrence (exactly 180 degrees opposite)
                    slices.push({
                        text: text,
                        color: choiceColor,  // Same color as first occurrence
                        rotate: baseRotation + 180,  // Exactly opposite (180 degrees)
                        sliceAngle: sliceAngle
                    });
                });
            } else {
                // For 6 or more choices, create one slice per choice
                const sliceCount = choiceTexts.length;
                const sliceAngle = 360 / sliceCount;
                
                slices = choiceTexts.map((text, index) => {
                    const colorIndex = index % COLORS.length;
                    const choiceColor = COLORS[colorIndex] || '#6366f1'; // Default color if needed
                    
                    return {
                        text,
                        color: choiceColor,
                        rotate: index * sliceAngle,
                        sliceAngle
                    };
                });
            }
            
            // Double-check all slices have a valid color
            slices.forEach(slice => {
                if (!slice.color || slice.color === 'undefined') {
                    console.warn('Missing color detected, using default');
                    slice.color = '#6366f1'; // Default to indigo
                }
            });
            
            return slices;
        }

        // Add a new choice
        function addChoice() {
            const newChoiceText = newChoiceInput.value.trim();
            if (newChoiceText) {
                state.choices.push({
                    text: newChoiceText,
                    editing: false,
                    editValue: newChoiceText
                });
                newChoiceInput.value = '';
                renderChoicesList();
                renderWheel();
                
                // Update spin button state
                spinButton.disabled = state.isSpinning || state.choices.length === 0;
            }
        }

        // Start editing a choice
        function startEdit(index) {
            // First, close any other editing rows
            state.choices.forEach((choice, i) => {
                if (i !== index && choice.editing) {
                    updateChoice(i);
                }
            });
            
            // Then start editing the selected row
            state.choices[index].editing = true;
            state.choices[index].editValue = state.choices[index].text;
            renderChoicesList();
        }

        // Update a choice
        function updateChoice(index) {
            if (state.choices[index].editValue.trim()) {
                state.choices[index].text = state.choices[index].editValue.trim();
            }
            state.choices[index].editing = false;
            renderChoicesList();
            renderWheel();
        }

        // Delete a choice
        function deleteChoice(index) {
            state.choices.splice(index, 1);
            renderChoicesList();
            renderWheel();
            
            // Update spin button state
            spinButton.disabled = state.isSpinning || state.choices.length === 0;
        }

        // Spin the wheel
        function spinWheel() {
            if (state.isSpinning || state.choices.length === 0) return;
            
            state.isSpinning = true;
            state.result = '';
            resultMessage.style.display = 'none';
            spinButton.textContent = 'Spinning...';
            spinButton.disabled = true;
            
            // Random rotation between 1440 and 2160 degrees (4-6 full rotations)
            const minSpins = 4;
            const maxSpins = 6;
            const randomSpins = minSpins + Math.random() * (maxSpins - minSpins);
            const newRotation = state.rotation + (randomSpins * 360);
            
            state.rotation = newRotation;
            wheel.style.transform = `rotate(${newRotation}deg)`;
            
            // Calculate the result after spinning
            setTimeout(() => {
                const slices = getWheelSlices();
                const sliceAngle = slices[0].sliceAngle;
                
                // The modulo 360 of the final rotation tells us which slice is at the top
                const modRotation = newRotation % 360;
                
                // The indicator points to the top (0 degrees), so we need to find which slice is there
                // We add 360 to ensure positive values, then modulo 360 again
                const normalizedRotation = (360 - modRotation) % 360;
                
                // Find which slice corresponds to this rotation
                const resultIndex = Math.floor(normalizedRotation / sliceAngle);
                
                // Get the result text - make sure we don't exceed array bounds
                const safeIndex = resultIndex % slices.length;
                const resultText = slices[safeIndex].text;
                
                // Use the text as the result (handles duplicated choices correctly)
                state.result = resultText;
                resultElement.textContent = state.result;
                resultMessage.style.display = 'block';
                
                state.isSpinning = false;
                spinButton.textContent = 'Spin the Wheel';
                spinButton.disabled = false;
            }, 5000); // Wait for the spin animation to complete (5 seconds)
        }

        // Initialize the wheel with optional parameters
        function initializeWheel(initialChoices) {
            // If initial choices are provided, use them
            if (initialChoices && Array.isArray(initialChoices) && initialChoices.length > 0) {
                state.choices = initialChoices.map(text => ({
                    text: text,
                    editing: false,
                    editValue: text
                }));
            }
            
            // Initial render
            renderChoicesList();
            renderWheel();
            
            // Update spin button state
            spinButton.disabled = state.isSpinning || state.choices.length === 0;
        }

        // Event listeners
        spinButton.addEventListener('click', spinWheel);
        
        newChoiceInput.addEventListener('keyup', function(event) {
            if (event.key === 'Enter') {
                addChoice();
            }
        });
        
        // Initialize the wheel
        // You can call this with an array of choices, e.g.:
        // initializeWheel(['Pizza', 'Burger', 'Sushi', 'Tacos']);
        // Or without parameters for an empty wheel:
        initializeWheel();

        // Example of how to initialize with URL parameters:
        function initializeFromURL() {
            // Check if there are choices in the URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const choicesParam = urlParams.get('choices');
            
            if (choicesParam) {
                try {
                    // Parse JSON array from URL parameter
                    const initialChoices = JSON.parse(decodeURIComponent(choicesParam));
                    if (Array.isArray(initialChoices)) {
                        initializeWheel(initialChoices);
                        return true;
                    }
                } catch (e) {
                    console.warn('Invalid choices parameter in URL');
                }
            }
            
            // Default initialization with example choices (comment out for fully empty wheel)
            // initializeWheel(['Pizza', 'Burger', 'Sushi', 'Tacos']);
            
            // Or initialize with empty wheel
            initializeWheel();
            return false;
        }
        
        // Initialize the app
        initializeFromURL();
    </script>
</body>
</html> 